import { Vector2, Vector3 } from "three";
import { TerrainOptions } from "./basicTypes";
import { Clamp } from "./filters";
import { Linear } from "./core";

interface DistanceMetrics {
    [index: string]: (a: Vector2, b: Vector2) => number;
}

/**
 * A set of functions to calculate the 2D distance between two vectors.
 */
const distanceMetrics: DistanceMetrics = {
    distanceToManhattan: function (a: Vector2, b: Vector2): number {
        return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
    },

    distanceToChebyshev: function (a: Vector2, b: Vector2): number {
        var c = Math.abs(a.x - b.x),
            d = Math.abs(a.y - b.y);
        return c <= d ? d : c;
    },

    distanceToQuadratic: function (a: Vector2, b: Vector2): number {
        var c = Math.abs(a.x - b.x),
            d = Math.abs(a.y - b.y);
        return c * c + c * d + d * d;
    },

    distanceTo: function (a: Vector2, b: Vector2): number {
        return a.distanceTo(b);
    },

    distanceToSquared: function (a: Vector2, b: Vector2): number {
        return a.distanceToSquared(b);
    }
}


/**
 * Find the Voronoi centroid closest to the current terrain vertex.
 *
 * This approach is naive, but since the number of cells isn't typically
 * very big, it's plenty fast enough.
 *
 * Alternatives approaches include using Fortune's algorithm or tracking
 * cells based on a grid.
 */
function distanceToNearest(coords: Vector2, points: Vector2[], distanceType: string) {
    var color = Infinity,
        distanceFunc = distanceMetrics['distanceTo' + distanceType];
    for (var k = 0; k < points.length; k++) {
        var d = distanceFunc(points[k], coords);
        if (d < color) {
            color = d;
        }
    }
    return color;
}

interface WorleyOptions extends Pick<TerrainOptions, 'xSegments' | 'ySegments' | 'minHeight' | 'maxHeight'> {
    /**
     * The name of a method to use to calculate the
     * distance between a point in the heightmap and a Voronoi centroid in
     * order to determine the height of that point. Available methods
     * include 'Manhattan', 'Chebyshev', 'Quadratic', 'Squared' (squared
     * Euclidean), and '' (the empty string, meaning Euclidean, the
     * default).
     **/
    distanceType?: string;

    /**
     * A function that takes the distance
     * from a heightmap vertex to a Voronoi centroid and returns a relative
     * height for that vertex.Defaults to function(d) { return -d; }.
     * Interesting choices of algorithm include
     * `0.5 + 1.0 * Math.cos((0.5*d-1) * Math.PI) - d`, which produces
     * interesting stepped cones, and`-Math.sqrt(d)`, which produces sharp
     * peaks resembling stalagmites.
     */
    worleyDistanceTransformation?: (d: number) => number;

    /**
     * A function to use to distribute Voronoi
     * centroids.Available methods include
     * `THREE.Terrain.Worley.randomPoints`(the default ),
     * `THREE.Terrain.Worley.PoissonDisks`, and any function that returns
     * an array of`THREE.Vector2` instances.You can wrap the PoissonDisks
     * function to use custom parameters.
     */
    worleyDistribution?: (width: number, height: number, numPoints: number) => Vector2[];

    /**
     * The number of Voronoi cells to use(must be at least
     * one).Calculated by default based on the size of the terrain.
     */
    worleyPoints?: number;
}

/**
 * Generate random terrain using Worley noise.
 *
 * Worley noise is also known as Cell or Voronoi noise. It is generated by
 * scattering a bunch of points in heightmap-space, then setting the height
 * of every point in the heightmap based on how close it is to the closest
 * scattered point (or the nth-closest point, but this results in
 * heightmaps that don't look much like terrain).
 *
 * @param {THREE.Vector3[]} g
 *   The vertex array for plane geometry to modify with heightmap data.
 *   This method sets the `z` property of each vertex.
 * @param {Object} options
 *   A map of settings that control how the terrain is constructed and
 *   displayed. Valid values are the same as those for the `options`
 *   parameter of {@link THREE.Terrain}(), plus three additional available
 *   properties (see interface type `WorleyOptions`).
 */
export function Worley(g: Vector3[], options: WorleyOptions) {
    var points = (options.worleyDistribution || randomPoints)(options.xSegments, options.ySegments, options.worleyPoints!),
        transform = options.worleyDistanceTransformation || function (d) { return -d; },
        currentCoords = new Vector2(0, 0);
    // The height of each heightmap vertex is the distance to the closest Voronoi centroid
    for (var i = 0, xl = options.xSegments! + 1; i < xl; i++) {
        for (var j = 0; j < options.ySegments! + 1; j++) {
            currentCoords.x = i;
            currentCoords.y = j;
            g[j * xl + i].z = transform(distanceToNearest(currentCoords, points, options.distanceType || ''));
        }
    }
    // We set the heights to distances so now we need to normalize
    Clamp(g, {
        maxHeight: options.maxHeight,
        minHeight: options.minHeight,
        stretch: true,
        easing: Linear
    });
};

/**
 * Randomly distribute points in space.
 */
export function randomPoints(width: number, height: number, numPoints: number) {
    numPoints = numPoints || Math.floor(Math.sqrt(width * height * 0.025)) || 1;
    var points = new Array(numPoints);
    for (var i = 0; i < numPoints; i++) {
        points[i] = new Vector2(
            Math.random() * width,
            Math.random() * height
        );
    }
    return points;
};

/* Utility functions for Poisson Disks. */

function removeAndReturnRandomElement(arr: Vector2[]) {
    return arr.splice(Math.floor(Math.random() * arr.length), 1)[0];
}

function putInGrid(grid: Vector2[][], point: Vector2, cellSize: number): void {
    var gx = Math.floor(point.x / cellSize),
        gy = Math.floor(point.y / cellSize);
    if (!grid[gx]) grid[gx] = [];
    grid[gx][gy] = point;
}

function inRectangle(point: Vector2, width: number, height: number): boolean {
    return point.x >= 0 &&
        point.y >= 0 &&
        point.x <= width + 1 &&
        point.y <= height + 1;
}

function inNeighborhood(grid: Vector2[][], point: Vector2, minDist: number, cellSize: number): boolean {
    var gx = Math.floor(point.x / cellSize),
        gy = Math.floor(point.y / cellSize);
    for (var x = gx - 1; x <= gx + 1; x++) {
        for (var y = gy - 1; y <= gy + 1; y++) {
            if (x !== gx && y !== gy &&
                typeof grid[x] !== 'undefined' && typeof grid[x][y] !== 'undefined') {
                var cx = x * cellSize,
                    cy = y * cellSize;
                if (Math.sqrt((point.x - cx) * (point.x - cx) + (point.y - cy) * (point.y - cy)) < minDist) {
                    return true;
                }
            }
        }
    }
    return false;
}

function generateRandomPointAround(point: Vector2, minDist: number): Vector2 {
    var radius = minDist * (Math.random() + 1),
        angle = 2 * Math.PI * Math.random();
    return new Vector2(
        point.x + radius * Math.cos(angle),
        point.y + radius * Math.sin(angle)
    );
}

/**
 * Generate a set of points using Poisson disk sampling.
 *
 * Useful for clustering scattered meshes and Voronoi cells for Worley noise.
 *
 * Ported from pseudocode at http://devmag.org.za/2009/05/03/poisson-disk-sampling/
 *
 * @param {Object} options
 *   A map of settings that control how the resulting noise should be generated
 *   (with the same parameters as the `options` parameter to the
 *   `THREE.Terrain` function).
 *
 * @return {THREE.Vector2[]}
 *   An array of points.
 */
export function PoissonDisks(width: number, height: number, numPoints: number) {
    numPoints = numPoints || Math.floor(Math.sqrt(width * height * 0.2)) || 1;
    let minDist = Math.sqrt((width + height) * 2.5);
    if (minDist > numPoints * 0.67) minDist = numPoints * 0.67;
    var cellSize = minDist / Math.sqrt(2);
    if (cellSize < 2) cellSize = 2;

    var grid: Vector2[][] = [];

    var processList: Vector2[] = [],
        samplePoints: Vector2[] = [];

    var firstPoint = new Vector2(
        Math.random() * width,
        Math.random() * height
    );
    processList.push(firstPoint);
    samplePoints.push(firstPoint);
    putInGrid(grid, firstPoint, cellSize);

    var count = 0;
    while (processList.length) {
        var point = removeAndReturnRandomElement(processList);
        for (var i = 0; i < numPoints; i++) {
            // optionally, minDist = perlin(point.x / width, point.y / height)
            var newPoint = generateRandomPointAround(point, minDist);
            if (inRectangle(newPoint, width, height) && !inNeighborhood(grid, newPoint, minDist, cellSize)) {
                processList.push(newPoint);
                samplePoints.push(newPoint);
                putInGrid(grid, newPoint, cellSize);
                if (samplePoints.length >= numPoints) break;
            }
        }
        if (samplePoints.length >= numPoints) break;
        // Sanity check
        if (++count > numPoints * numPoints) {
            break;
        }
    }
    return samplePoints;
};
